const axios = require("axios");

class GitHubService {
  constructor() {
    this.baseURL = "https://api.github.com";
    this.token = process.env.GITHUB_TOKEN;
  }

  async getPRFiles(owner, repo, prNumber) {
    const url = `${this.baseURL}/repos/${owner}/${repo}/pulls/${prNumber}/files`;
    const response = await axios.get(url, {
      headers: {
        Authorization: `token ${this.token}`,
        Accept: "application/vnd.github.v3+json",
      },
    });
    return response.data; // array of changed files
  }

  mapLineToPosition(files, comments) {
    const mapped = [];

    for (const comment of comments) {
      const file = files.find((f) => f.filename === comment.path);
      if (!file || !file.patch) {
        console.warn(`‚ö†Ô∏è Skipped comment: file not found or no patch for ${comment.path}`);
        continue;
      }

      const diffLines = file.patch.split("\n");
      let position = null;

      // Walk through patch lines
      let currentLine = 0;
      for (let i = 0; i < diffLines.length; i++) {
        const line = diffLines[i];

        if (line.startsWith("@@")) {
          // Parse hunk header: @@ -a,b +c,d @@
          const match = /@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@/.exec(line);
          if (match) {
            currentLine = parseInt(match[1], 10); // starting line number in new file
          }
          continue;
        }

        if (line.startsWith("+")) {
          if (currentLine === comment.line) {
            position = i + 1; // position is 1-based index in patch
            break;
          }
          currentLine++;
        } else if (!line.startsWith("-")) {
          currentLine++;
        }
      }

      if (position) {
        mapped.push({
          path: comment.path,
          position,
          body: `ü§ñ **AI Suggestion:** ${comment.body}`,
        });
        console.log(`‚úÖ Mapped comment for ${comment.path} line ${comment.line} ‚Üí position ${position}`);
      } else {
        console.warn(
          `‚ö†Ô∏è Skipped comment: Could not map line ${comment.line} in ${comment.path}`
        );
      }
    }

    return mapped;
  }

  async postReviewComment(repo, prNumber, reviewData) {
  try {
    const [owner, repoName] = repo.split("/");

    let event = "COMMENT";
    if (reviewData.score < 50) event = "REQUEST_CHANGES";
    else if (reviewData.score >= 80) event = "APPROVE";

    // üîë Fetch PR files
    const files = await this.getPRFiles(owner, repoName, prNumber);

    // üìù Log exact filenames from GitHub PR
    console.log("üìÑ PR files:", files.map(f => f.filename));

    // Map AI comments to positions
    const inlineComments = this.mapLineToPosition(files, reviewData.comments);

    const reviewPayload = {
      body: this.formatReviewBody(reviewData),
      event,
      comments: inlineComments,
    };

    const response = await axios.post(
      `${this.baseURL}/repos/${owner}/${repoName}/pulls/${prNumber}/reviews`,
      reviewPayload,
      {
        headers: {
          Authorization: `token ${this.token}`,
          Accept: "application/vnd.github.v3+json",
          "User-Agent": "AI-Code-Reviewer",
        },
      }
    );

    console.log(`‚úÖ Review posted to PR #${prNumber} with event: ${event}`);
    return response.data;
  } catch (error) {
    console.error(
      "‚ùå Failed to post review to GitHub:",
      error.response?.data || error.message
    );
    throw error;
  }
}



  formatReviewBody(reviewData) {
    return `## ü§ñ AI Code Review Summary

**Overall Score: ${reviewData.score}/100**

${reviewData.summary}

### üìä Category Scores:
- ‚úÖ **Lint & Style**: ${reviewData.categories.lint}/100
- üêõ **Bug Detection**: ${reviewData.categories.bugs}/100  
- üîí **Security**: ${reviewData.categories.security}/100
- ‚ö° **Performance**: ${reviewData.categories.performance}/100

*This review was automatically generated by an AI code review system.*`;
  }
}

module.exports = new GitHubService();
